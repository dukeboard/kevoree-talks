<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Triskell 2011</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=1274, user-scalable=no">
    <link rel="stylesheet" href="themes/kevs/styles/screen.css">
    <link rel="stylesheet" href="themes/kevs/styles/print.css" media="print">
    <link type="text/css" rel="stylesheet" href="styles/shCoreDefault.css"/>
    <script type="text/javascript" src="scripts/brush/shCore.js"></script>
    <script type="text/javascript" src="scripts/brush/shBrushJScript.js"></script>
    <script type="text/javascript" src="scripts/brush/shBrushXml.js"></script>
    <script type="text/javascript" src="scripts/brush/shBrushJava.js"></script>
    <script type="text/javascript">SyntaxHighlighter.all();</script>

    <!--<link rel="stylesheet/less" type="text/css" href="http://twitter.github.com/bootstrap/assets/css/bootstrap.css"> -->
    <!--
    <link rel="stylesheet/less" type="text/css" href="less/code.less">    <script src="scripts/less-1.3.0.min.js" type="text/javascript"></script>
    -->
    <!--
         To apply styles to the certain slides         set slide ID to get needed elements
         -->
    <style>





        .slide ul > li > ul > li:before  {
            content:'\2022'; /* bull */
            line-height:20px;
            font-size:20px;
            }

         .slide ul > li > ul{
             line-height:20px;
             font-size:20px;
         }

         .slide ul > li > ul > li > ul > li:before  {
             content:'-'; /* bull */
             line-height:16px;
             font-size:16px;
         }

         .slide ul > li > ul > li > ul{
             line-height:16px;
             font-size:16px;
         }

        .slide ul > ul > li:before  {
            content:'\2022'; /* bull */
            line-height:20px;
            font-size:20px;
        }

        .slide ul >  ul{
            line-height:20px;
            font-size:20px;
        }

        .slide ul >  ul > li > ul > li:before  {
            content:'-'; /* bull */
            line-height:16px;
            font-size:16px;
        }

        .slide ul > ul > li > ul{
            line-height:16px;
            font-size:16px;
        }




        #Cover {
        background: #3d3d3d;
        font: 12px 'Lucida Grande', Arial, sans-serif;
        }
        #Cover header {
        font-size: 40px;
        color: black;
        background: white;
        margin: 250px -120px;
        padding: 0.6em 120px 0.3em;
        -webkit-border-radius: 8px;
        -moz-border-radius: 8px;
        border-radius: 8px;
        }
        #Cover h2 {
	        font-size: 1.4em;
        margin: 0.3em 0
        }
        #Cover p {
        font-weight: normal;
        }
        #Picture h2 {
        color:#FFF;
        }
        .codebox {
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -o-pre-wrap;
        background: #3d3d3d;
        -webkit-border-radius: 8px;
        -moz-border-radius: 8px;
        border-radius: 8px;
        font-size: 16px;
        }
        details { display: none; }
    </style>
</head>
<body class="list">
<header class="caption">
    <h2>Working in the Triskell group</h2>

    <p><a href="http://www.irisa.fr/triskell">Triskell Team</a></p>
</header>





    <section class='slide'>
      <h2></h2>
      <ul>
          <li>TAA</li>
          <li>Olivier Barais</li>
        <li>Programmation orientée composant</li>
        <li>D’après les cours des membres du projet Jacquard</li>
        <li>L. Duchien, L. Seinturier, R. Marvie, O. Caron, R. Pawlak, P. Merle</li>
        <li>Olivier Barais</li>
        <li>IFSIC</li>
        <li>Université de Rennes 1</li>
        <li>barais@irisa.fr</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Au sommaire du cours  (1/2)</h2>
      <ul>
         <li >Introduction à la notion de composant
          <ul >
              <li>Objectif</li>
        <li>Caractérisation</li>
        <li>Rappel sur les objets répartis</li></ul></li>
        <li>Les EJBs					3 TPs</li>
          <li>Introduction aux SOA
          <ul><li>Web services					1 TP</li>
              <li>OSGI					1 TP</li>
          </ul></li>
          </ul>
    </section>
<section class='slide'>
    <h2>Au sommaire du cours (2/2)</h2>
    <ul>
<li>Spring 					3 TPs</li>
      <ul><li>Le framework Spring</li>
        <li>La programmation par aspects</li>
        <li>Spring DM (OSGi + Spring)</li>
      </ul><li>Cloud computing selon google</li>
      <ul><li>GAE et GWT					1 TP</li>
      </ul>
      </ul>
    </section>
<section class='slide'>
      <h2>Au sommaire aujourd’hui</h2>
      <ul>
         <li style="color: RED;">Vers la notion de composant</li>
      </ul>
        <ul><li>Architecture JEE</li>
            <ul><li>1. 	 JavaEE Introduction</li>
             <li>2. JavaEE Architecture</li>

                    <li>3.  Rappel sur le middleware</li>
        <li>4. 	Des spécifications sous forme d’APIs</li>
        <li>5.  	Composants Web</li>
        </ul>
      </ul>
    </section>
    <section class='slide'>
      <h2>Limites de la programmation OO</h2>
      <ul>
         <li>beaucoup de tâches doivent être gérées manuellement
          <ul><li>définition des instances</li>
        <li>références directes entre les instances + appels explicites de méthodes</li>
        <li>gestion des dépendances entre classes</li></ul></li>
        <li>structure des applications peu lisible ( = un ensemble de fichiers )</li>
        <li>évolutions/modifications difficiles
          <ul><li>changement de modes de communication</li>
        <li>évolution, ajout, suppression de services système</li>
        <li>assemblage</li></ul></li>
        <li>Déploiement (<=> installation)
          <ul><li> peu ou pas d’outils pour installer les exécutables sur les différents sites</li></ul></li>
      </ul>
    </section>
    <section class='slide'>
      <h2>Limites de la programmation OO</h2>
      <ul>
         <li>Objets prônent l'encapsulation pour masquer l'implantation<ul>
        <li>utilisation d'un objet via une interface 	&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp; ok</li>
        <li>construction d'une appli à l'aide de classes	&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;	not(ok)</li></ul></li>
        <li>ouvrir boîte noire<ul>
        <li>soit pour introduire des refs vers d'autres objets</li>
        <li>soit pour hériter d'autres classes</li></ul></li>
        <li>Fragile Base Class problem<ul>
        <li align="justify"><i>The fragile base class problem is a fundamental architectural problem of object-oriented programming systems where base classes (superclasses) are considered "fragile" because seemingly safe modifications to a base class, when inherited by the derived classes, may cause the derived classes to malfunction. The programmer cannot determine whether a base class change is safe simply by examining the base class's methods in isolation.</i></li>
        </ul></li>
      </ul>
    </section>
    <section class='slide'>
      <h2>Motivation pour la programmation orientée composant</h2>
        <p><i>"Programming in the large vs programming in the small"</i></p>
      <ul>
        <li style="font-size: 22px;">construction d’applications par assemblage d’entités existantes (composants)</li>
        <li style="font-size: 22px;">définition de connecteurs et de schémas de connexions entre les composants
        <ul>
        <li>définition d'une architecture logicielle</li>
        <li>formalisme pour décrire les interactions entre composants</li>
        <li>formalisme pour décrire le déploiement des composants</li>
        <li>programmation à gros grain ( "in the large" )</li></ul></li>
        <li style="font-size: 22px;">Programmation orientée composant
        <ul>
            <li>= programmation par assemblage
                plutôt que par développement (cas de la prog. OO)</li>
        <li>focaliser l’expertise sur les problèmes "métiers" plutôt que "techniques"</li>
        <li>un autre pas vers "encore plus" de réutilisabilité</li></ul></li>

      </ul>
        <object data="images/image1.jpeg" type="image/jpg" style="position:absolute;top:57%;left:80%;" height="20%"
                            width="20%"></object>

    </section>
    <section class='slide'>
      <h2>Définition d'un composant</h2>
      <ul>
         <li>Pb : pas de consensus actuellement sur une définition commune<ul>
        <li> <i align="justify">Un composant est un morceau de logiciel assez petit pour que l'on puisse le créer et le maintenir et en assurer le support. De + il est doté d'interfaces standards pour pouvoir intéropérer.	[Jed Harris 1995]</i></li>
        <li><i align="justify">A software component is a unit of composition with contractually specified interfaces and explicit context dependencies only. A software component can be deployed independantly and is subject to composition by third parties.	[Szyperski 1996]</i></li></ul></li>
        <li>chaque plate-forme a sa définition de composant</li>
      </ul>
        <b align="center">mais objectif commun : augmenter réutilisation et la composabilité</b>

    </section>
    <section class='slide'>
      <h2>Caractérisation d’un composant</h2>
      <ul>
          <li>module logiciel
          <ul><li>qui exporte des propriétés et opérations </li>
              <li>qui est prévu pour être configuré	 &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; propriétés initialisables (ex. XML)</li>
              <li>qui est prévu pour être installé	&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; paquetage (ex. .war .ear)</li>
              <li>qui est révu pour être composé	&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connecteurs</li>
              <li>qui fournit un mécanisme lui permettant de «s'auto-décrire»</li></ul></li>


          <li>Réification de la notion de connexions entre composants<ul>

          <li>types de connecteur : synchrone, asynchrone, diffusion, avec QoS, ...</li>
          </ul></li>
      </ul>
        <object data="images/composant.png" type="image/jpg" style="position:absolute;top:70%;left:20%;" height="20%"
                width="60%"></object>

    </section>
    <section class='slide'>
      <h2>Caractérisation d’un composant</h2>
      <ul>
        <li>Propriétés configurables du composant</li>
        <li>Comment coopère un composant<ul>
        <li>Ce que fournit le composant (entrées)</li>
        <li>composantes, interfaces, opérations, propriétés</li>
        <li>Ce qu’utilise le composant (dépendances)</li>
        <li>composition et références aux autres composants</li>
        <li style="width: 50%;"
              >modes de communication des connecteurs (synchrone, asynchrone, flots)</li></ul></li>
        <li>Contraintes techniques (QoS)<ul>
        <li style="width: 50%;">bus logiciel (« middleware ») : placement, sécurité, transaction</li>
        <li>internes : cycle de vie, persistance</li>
        <li>implantation : OS, bibliothèques, version</li>
        <li>Composant</li>
        <li>Contraintes</li>
        <li>techniques</li></ul></li>

      </ul>
        <object data="images/composant1.png" type="image/jpg" style="position:absolute;top:25%;left:60%;" height="70%"
                width="45%"></object>

    </section>
    <section class='slide'>
      <h2>Un terme, plusieurs sens</h2>
      <ul>
         <li>1 type de composant <i style="font-size: 15px;">(Idem pour connecteur et composite)</i><ul>
        <li>Peut être réalisé par plusieurs implantations</li>
        <li>Peut être conditionné dans plusieurs paquetages</li>
        <li>Peut être instancié par plusieurs instances</li></ul></li>
        <li>1 implantation de composant <i style="font-size: 15px;">(Idem pour connecteur et composite)</i><ul>
        <li>Réalise 1 seul type de composant</li>
        <li>Peut être conditionné dans plusieurs paquetages</li>
        <li>Peut être instancié par plusieurs instances</li></ul></li>
        <li>1 paquetage de composant <i style="font-size: 15px;">(Idem pour connecteur et composite)</i><ul>
        <li>Réalise 1 seul type de composant</li>
        <li>Peut conditionner plusieurs implantations</li>
        <li>Peut être instancié par plusieurs instances</li></ul></li>
        <li>1 instance de composant <i style="font-size: 15px;">(Idem pour connecteur et composite)</i><ul>
        <li>1 seul  type</li>
        <li>1 seule implantation</li>
        <li>1 seul paquetage</li></ul></li>
      </ul>
        <object data="images/composant3.png" type="image/jpg" style="position:absolute;top:50%;left:65%;" height="45%"
                width="35%"></object>
    </section>
    <section class='slide'>
      <h2>Processus d’ingénierie logicielle</h2>
      <ul ><ul>
         <li>Conception<ul>
        <li>Analyser les besoins</li>
        <li>Capturer des types de composants</li></ul></li>
        <li>Développement<ul>
        <li>Type de composant - > implantations de composants</li></ul></li>
        <li>Test<ul>
        <li>Respect du contrat de conception par les implantations de composants</li></ul></li>
        <li>Conditionnement<ul>
        <li>Implantations de composants - > archive de composant</li></ul></li>
        <li>Assemblage<ul>
        <li>Composition d’archives de composants</li></ul></li>
        <li>Déploiement<ul>
        <li>Composition - > instances de composants</li></ul></li>
        <li>Administration<ul>
        <li>Reconfigurer les instances de composants</li></ul></li>
        <li>Besoin d’un processus global d’ingénierie du logiciel<ul>
        <li>=> Des rôles / acteurs, des paradigmes / langages, des outils pour chaque étape</li></ul></li>
      </ul></ul>
        <object data="images/composant4.png" type="image/jpg" style="position:absolute;top:27%;left:65%;" height="40%"
                width="15%"></object>
    </section>
    <section class='slide'>
      <h2>Notion de séparation Interface - Implantation</h2>
      <ul>
         <li>Interface = ensemble d’opérations publiques</li>
        <li>La séparation Interface – Implantation permet de <ul>
        <li>Caractériser le protocole d’accès à un composant logiciel indépendamment de son implantation</li>
        <li>Réaliser plusieurs implantations de la même interface</li>
        <li>Favoriser la substitution d’implantations</li></ul></li>

      </ul>
        <object data="images/composant7.jpg" type="image/jpg" style="position:absolute;top:70%;left:25%;" height="28%"
                width="50%"></object>

    </section>
    <section class='slide'>
      <h2>Langage de définition d’interfaces</h2>
      <ul>
         <li>Divers langages de définition d’interfaces<ul>
        <li>Interface Definition Language (IDL)</li>
        <li>Permet de décrire des interfaces</li>
        <li>Opérations, paramètres, exceptions et types de données</li>
        <li>Environnements hétérogènes</li>
        <li>OMG Interface Definition Language (OMG IDL)</li>
        <li>Microsoft IDL</li>
        <li>Web Services Definition Language (WSDL)</li>
        <li>…</li>
        <li>Environnements homogènes</li>
        <li>Interfaces Java</li></ul></li>
        <li>Génération automatique de souches et de squelettes de communication</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Séparation Interface / Implantation</h2>
        <object data="images/composant8.png" type="image/jpg" style="position:absolute;top:25%;left:20%;" height="60%"
                width="60%"></object>

    </section>
    <section class='slide'>
      <h2>Notion d’adaptateur</h2>
      <ul>
         <li>Adaptateur = entité gérant l’impédance entre interfaces du client et celles du service<ul>
        <li>Conversion de paramètres</li>
        <li>1 appel client - > plusieurs appels du service</li>
         </ul></li>
      </ul>
        <object data="images/composant9.png" type="image/jpg" style="position:absolute;top:55%;left:15%;" height="30%"
                width="70%"></object>

    </section>
    <section class='slide'>
      <h2>Notion de fabrique / maison</h2>
      <ul>
         <li>Fabrique = création dynamique d’instances<ul>
        <li>Permet d’éviter de connaître en dur les implantations</li>
        <li>Aussi nommée maison</li></ul></li>
        <li>Quid création des fabriques ?<ul>
        <li>Fabrique générique, i.e. fabrique de fabriques</li></ul></li>

      </ul>
        <object data="images/composant10.png" type="image/jpg" style="position:absolute;top:54%;left:20%;" height="40%"
                width="60%"></object>

    </section>
    <section class='slide'>
      <h2>Notion de port</h2>
      <ul>
         <li>Un composant interagit avec l'extérieur via des ports offerts et requis</li>
        <li>Un port = 1 ou plusieurs interfaces</li>
        <li>Ports offerts = exportation vers le monde extérieur<ul>
        <li>Implantés dans le code du composant </li>
        <li>Aussi nommés interfaces offertes ou serveurs</li></ul></li>
        <li>Ports requis = importation depuis le monde extérieur <ul>
        <li>Utilisés depuis le code du composant
        <li>Aussi nommés interfaces requises ou clientes</li>
        </ul></li>

      </ul>
        <object data="images/composant11.png" type="image/jpg" style="position:absolute;top:73%;left:20%;" height="20%"
                width="60%"></object>
    </section>
    <section class='slide'>
      <h2>Assemblage de composants</h2>
      <ul>
         <li>Liaison ou binding<ul>
        <li>association entre 1 interface requise et 1 interface fournie</li>
        <li>Compatibilité des interfaces, e.g.<ul>
        <li>I3 sous-type de I1</li>
        <li>I4 sous-type de I2</li></ul></li></ul></li>
        <li>Pour simple assemblage de composants non répartis<ul>
        <li>Pas de communication réseau via un intergiciel</li></ul></li>
      </ul>
        <object data="images/composant12.png" type="image/jpg" style="position:absolute;top:53%;left:20%;" height="40%"
                width="60%"></object>

    </section>
    <section class='slide'>
      <h2>Notion de connecteur</h2>
      <ul>
         <li>Connecteur = objet de communication<ul>
        <li>Capturant interactions entre composants répartis</li>
        <li>Encapsulant mécanismes de communication des intergiciels</li></ul></li>
        <li>Peut servir à résoudre l’impédance entre les ports des composants<ul>
        <li>Adaptateur pour changement des noms d’opérations, des types, des paramètres, etc.</li></ul></li>
        <li>Divers modèles d’interactions<ul>
        <li>Client / serveur par invocation synchrone d’opérations</li>
        <li>Producteur / consommateur par envoi asynchrone  de messages</li>
        <li>Diffusion, mémoire partagée, etc.</li></ul></li>
        <li>Diverses cardinalités <i style="font-size: 15px;"> (1 -> 1 ; 1 -> n ;  n -> 1 ; n -> m)</i></li>
        <li>Diverses propriétés extra-fonctionnelles<ul>
        <li>Couche de transport réseau : TCP/IP, UDP, IP Multicast, ...</li>
        <li>Couche protocolaire : IIOP, HTTP, ...</li>
        <li>Format d’encodage : CDR, XML, ...</li>
        <li>Compression, sécurité, transaction, QoS, …</li></ul></li>
      </ul>
    </section>
    <section class='slide'>
      <h2>Trois exemples de connecteurs</h2>
      <ul>
          <object data="images/composant13.png" type="image/jpg" style="position:absolute;top:25%;left:10%;" height="70%"
                  width="80%"></object>

      </ul>
    </section>
    <section class='slide'>
      <h2>Notion de configuration</h2>
      <ul>
         <li>Configuration = ensemble de composants reliés par des liaisons et connecteurs
         </li>
      </ul>
        <object data="images/composant14.png" type="image/jpg" style="position:absolute;top:37%;left:10%;" height="60%"
                width="80%"></object>
    </section>
    <section class='slide'>
      <h2>Notion de composite</h2>
      <ul>
         <li>Composite = composant encapsulant configuration<ul>
        <li>Aussi composants hiérarchiques</li></ul></li>
      </ul>
        <object data="images/composant15.png" type="image/jpg" style="position:absolute;top:37%;left:10%;" height="60%"
                width="80%"></object>
    </section>
    <section class='slide'>
      <h2>A vous de jouer !</h2>
      <ul>
         <li>Pouvez-vous définir un schéma UML qui représente les éléments d’un modèle de composant et leurs relations?</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>composant, port, connecteur, configuration et composite</h2>
        <object data="images/composant16.png" type="image/jpg" style="position:absolute;top:30%;left:10%;" height="65%"
                width="80%"></object>
    </section>
    <section class='slide'>
      <h2>Notion d’architecture</h2>
      <ul>
         <li>Trait d'union entre  <ul>
        <li>Le cahier des charges d'un programme</li>
        <li>Les méthodes de conception</li>
        <li>La mise en œuvre</li>
        <li>L'installation en environnement réparti</li></ul></li>
        <li>Synthétise la complexité d'un système</li>
        <li>Facilite l’installation et l’évolution de l’application<ul>
        <li>Automatise le processus d’installation de l’application
        <li>Puis permet l’évolution de l’application
        <ul><li>la modification des constituants d'un système</li>
        <li>la modification des interconnexions entre ces constituants</li>
        <li>la modification du placement</li></ul></li></ul></li>

      </ul>
        <object data="images/image2.jpeg" type="image/jpg" style="position:absolute;top:30%;left:70%;" height="20%"
                            width="25%"></object>
    </section>
    <section class='slide'>
      <h2>Why designing a software architecture ?</h2>
      <ul>
         <li>Understanding<ul>
        <li>High-level system structure</li></ul></li>
        <li>Automated analysis</li>
        <li>Blueprint for c onstruction<ul>
        <li>Basis to generate code</li>
        <li>Basis to identify opportunities for reuse</li></ul></li>
        <li>Program evolution support<ul>
        <li>Preservation of invariants</li>
        <li>Effect of changes</li></ul></li>
      </ul>

        <p>Garlan and shaw [92]</p>

        <object data="images/composant17.png" type="image/jpg" style="position:absolute;top:75%;left:70%;" height="15%"
                width="25%"></object>

    </section>
    <section class='slide'>
      <h2>Les langages de description d’architecture</h2>
      <ul>
         <li>Architecture Description Language (ADL) = langage déclaratif</li>
        <li>Description de la structure / architecture de l’application<ul>
        <li>A des fins de lisibilité et de réutilisation</li>
        <li>Définition des composants<ul>
        <li>Interfaces, ports, propriétés de configuration = > types</li>
        <li>Implantations et dépendances</li></ul></li>
        <li>Définition des connecteurs<ul>
        <li>Description des interactions entre composants</li>
        <li>Mode communication, cardinalité, propriétés</li>
        <li>Adaptation pour impédance entre composants</li></ul></li>
        <li>Capturer les configurations ~ architecture<ul>
        <li>description de variables d'environnement (placement, regroupement, sécurité, etc.</li></ul></li></ul></li>
        <li>Vérification de la sémantique d’assemblage<ul>
        <li>Systèmes de type de composants caractérisant la nature du logiciel</li>
        <li>Conformité entre interfaces pour autoriser des interconnexions</li>
        <li>Spécification de contraintes globales sur le fonctionnement de l'application<ul>
        <li>validation, preuve</li></ul></li></ul></li>
        <li>Peu de solutions industrielles, principalement travaux de recherche</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Vue graphique d’un ADL</h2>
        <object data="images/composant18.png" type="image/jpg" style="position:absolute;top:20%;left:10%;" height="70%"
                width="80%"></object>
    </section>
    <section class='slide'>
      <h2>A vous de jouer !</h2>
      <ul>
         <li>Pouvez-vous représenter l’architecture de la clé USB suivante.</li>

      </ul>
        <object data="images/image3.png" type="image/jpg" style="position:absolute;top:40%;left:10%;" height="50%"
                            width="80%"></object>

    </section>
    <section class='slide'>
      <h2>Environnement d'exécution d'un composant</h2>
        <object data="images/composant19.png" type="image/jpg" style="position:absolute;top:23%;left:10%;" height="70%"
                width="80%"></object>
    </section>
    <section class='slide'>
      <h2>Environnement d'exécution d'un composant</h2>
      <ul>
         <li>Conteneur<ul>
        <li>encapsulation d'un composant</li>
        <li>prise en charge (masquage) des services systèmes</li>
        <li>prise en charge des connexions entre composants</li>
        <li>invocations et événements</li></ul></li>
        <li>Serveur d'applications<ul>
        <li>structure d'accueil pour les conteneurs</li>
        <li>espace d'exécution</li>
        <li>médiateur entre les conteneurs et le système/ middleware</li></ul></li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Environnement d'exécution d'un composant</h2>
      <ul>
         <li>Idée sous-jacente<ul>
        <li>composants : code métier + configuration des services techniques</li>
        <li>conteneur + serveur : services techniques (non fonctionnels)</li></ul></li>
        <li>Objectifs<ul>
        <li>faciliter conception, développement, maintenance</li>
        <li>meilleure évolutivité / évolutions des solutions techniques</li></ul></li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Quelques modèles de composants</h2>
      <ul>
         <li>Modèles orientés IHM / client<ul>
        <li>Sur machines utilisateurs</li>
        <li>OLE, COM, ActiveX de Microsoft</li>
        <li>Java Beans de SUN</li></ul></li>
        <li>Modèles orientés métier / serveur<ul>
        <li>Sur machines serveurs</li>
        <li>Conteneurs en liaison avec BD, transactions, sécurité</li>
        <li>COM+, MTS, … .NET de Microsoft</li>
        <li>Entreprise Java Beans de SUN</li></ul></li>
        <li>Modèles généralistes<ul>
        <li>Fractal du consortium ObjectWeb</li>
        <li>Composants CORBA du consortium OMG</li></ul></li>

      </ul>
    </section>
<section class='slide'>
    <h2>Au sommaire aujourd’hui</h2>
    <ul>
        <li>Vers la notion de composant</li>
    </ul>
    <ul><li style="color: RED;">Architecture JEE</li>
        <ul><li>1. 	 JavaEE Introduction</li>
            <li>2. JavaEE Architecture</li>

            <li>3.  Rappel sur le middleware</li>
            <li>4. 	Des spécifications sous forme d’APIs</li>
            <li>5.  	Composants Web</li>
        </ul>
    </ul>
</section>


<section class='slide'>
      <h2>Des objets aux composants d’entreprise</h2>
      <ul>
         <li>Des objets trop complexes</li>
      </ul>
        <object data="images/image7.png" type="image/jpg" style="position:absolute;top:35%;left:20%;" height="60%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>Des objets aux composants d’entreprise</h2>
      <ul>
         <li>1ère étape :une meilleure structuration objet</li>

      </ul>
        <object data="images/image8.png" type="image/jpg" style="position:absolute;top:35%;left:10%;" height="60%"
                width="80%"></object>

    </section>
    <section class='slide'>
      <h2>Des objets aux composants d’entreprise</h2>
      <ul>
         <li>2nde étape : complète séparation, notion de conteneur</li>

      </ul>
        <object data="images/image9.png" type="image/jpg" style="position:absolute;top:35%;left:20%;" height="60%"
                width="60%"></object>

    </section>
    <section class='slide'>
      <h2>Plan de la présentation</h2>
      <ol>
         <li>JavaEE Introduction</li>
        <li>JavaEE Architecture</li>
        <li>Des spécifications sous forme d’APIs</li>
        <li>Composants Web</li>
        <li>Composants d’entreprise (EJB)</li>
        <li>Services techniques (du container)</li>
        <li>Déploiement</li>
        <li>Clients EJB</li>
        <li>Développement J2EE</li>
      </ol>
    </section>
    <section class='slide shout'>
      <h2>1. JavaEE Introduction</h2>
        <p align="center" style="color: RED;">JavaEE c’est quoi ?</p>
<!--        <p align="center" style="font-size: 10px;">http://java.sun.com/javaee <br>anciennement, J2EE (Java2 Enterprise Edition)<br>
        Architecture / Modèle de programmation<br>
        Spécifications<br>
        Implémentation de référence<br>
        Suite(s) de tests<br>
        Label Java EE Sun (qualification de plateformes)</p>-->

    </section>
    <section class='slide'>
      <h2>1. Java EE - Objectifs</h2>
      <ul>
         <li>Faciliter le développement de nouvelles applications à base de composants</li>
        <li>Intégration avec les systèmes d’information existants</li>
        <li>Support pour les applications « critiques » de l’entreprise<ul>
        <li>Disponibilité, tolérance aux pannes, montée en charge, securité ...</li></ul></li>

      </ul>
    </section>
    <section class='slide'>
      <h2>1. Java EE - C’est quoi?</h2>
      <ul>
         <li>Architecture / Modèle de programmation</li>
        <li>Spécifications<ul>
        <li>Programmation, assemblage, déploiement</li>
        <li>Serveur et services</li></ul></li>
        <li>Implémentation de référence opérationnelle</li>
        <li>Suite(s) de tests de conformance<ul>
        <li>Certification Sun</li>
        <li>Accès au processus de certification payant (cher !!)</li>
        <li>Lourd ( > 20.000 tests)</li></ul></li>
        <li>Label Java EE Sun (qualification de plateformes)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>1. Offre commerciale</h2>
      <ul>
         <li>BEA WebLogic (haut de gamme)</li>
        <li>IBM Websphere (no 1)</li>
        <li>Sun Java System App Server</li>
        <li>Borland Enterprise Server</li>
        <li>Oracle Application Server</li>
        <li>Macromedia jRun</li>
        <li>SAP Web application server</li>
        <li>Iona Orbix E2A</li>
        <li>…</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>1. Offre open-source</h2>
      <ul>
         <li>JBoss (no 1 en nombre de déploiements)</li>
        <li>ObjectWeb JOnAS(no 2, intégré à plusieurs distro Linux Entreprise)</li>
        <li>Sun JS App Server (Platform Edition)</li>
        <li>Apache Geronimo (démarrage fin 2003)</li>
        <li>openEjb</li>
        <li>ejBean</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>1. Evolution de Java EE</h2>
      <ul>
         <li>Standard en évolution depuis 1997<ul>
        <li>J2EE 1.0 à 1.4 en 2003, etc...</li></ul></li>
        <li>Au départ, applications Web n-tiers<ul>
        <li>Présentation (Servlets puis JSP), essentiellement HTTP</li>
        <li>Logique métier : EJB</li>
        <li>Données : JDBC</li></ul></li>
        <li>Puis infrastructure de support standard pour EAI<ul>
        <li>Facteurs de rationnalisation majeurs (JTA, JMS, JCA, Web Services)</li>
        <li>Evolution de progiciels existants vers Java EE</li></ul></li>
      </ul>
    </section>
    <section class='slide'>
      <h2>1. Vers Java EE 5</h2>
      <ul>
         <li>Simplification du développement<ul>
        <li>Utilisation des annotations amenées par Java SE 5</li>
        <li>Relâchement des contraintes / programmation des composants</li></ul></li>
        <li>Enrichissement fonctionnel<ul>
        <li>Amélioration du support du tiers de présentation avec JSF</li>
        <li>Support complet des Web Services</li>
        <li>Sessions exposables avec RMI ou avec Web Services</li></ul></li>
        <li>Amélioration du support des objets persistants avec Java<ul>
        <li>Persistence API (un grand pas vers JDO !!!)</li></ul></li>

      </ul>
    </section>
    <section class='slide shout'>
      <h2>2. Java EE - Architecture</h2>
      <ul>
 
      </ul>
    </section>
    <section class='slide'>
      <h2>2. Java EE - Architecture</h2>
      <ul>
         <li>La technologie EJB réutilise un nombre important de librairies Java<ul>
        <li>RMI-IIOP	: invocation de méthodes distantes</li>
        <li>JNDI		: accès à un service de nommage</li>
        <li>JDBC		: connexion à des bases de données</li>
        <li>JTS		: gestion des transactions (spec. basées sur CORBA OTS)</li>
        <li>JMS		: communications asynchrones</li>
        <li>JSP/servlet	: clients web</li></ul></li>
        <li>Architecture 3 tiers</li>
      </ul>
        <object data="images/composant41.png" type="image/jpg" style="position:absolute;top:65%;left:20%;" height="25%"
                  width="60%"></object>

    </section>
    <section class='slide'>
      <h2>2. Java EE - Architecture</h2>
        <object data="images/composant20.png" type="image/jpg" style="position:absolute;top:25%;left:10%;" height="65%"
                width="80%"></object>
    </section>
    <section class='slide'>
      <h2>2. Architecture multi-tiers</h2>
      <ul>
         <li>Client<ul>
        <li>Léger (Web, browser)</li>
        <li>Lourd (Application java, Applet…)</li>
        <li>Architecture orientée service (Application répartie sans présentation)</li></ul></li>
        <li>Serveur d ’applications<ul>
        <li>Conteneur EJB + logique métier</li>
        <li>Services non fonctionnels</li></ul></li>
        <li>EIS <i style="font-size: 10px;">(Executive Information System) </i>  ou Base de données</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>2. Un serveur Java EE</h2>
      <ul>
         <li>EJB Container</li>
        <li>JOnAS « Java EE » Server</li>

      </ul>
        <object data="images/image14.jpeg" type="image/jpg" style="position:absolute;top:30%;left:20%;" height="50%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>2. Java EE - Communications</h2>
      <ul>
 
      </ul>
    </section>
    <section class='slide'>
      <h2>2. Serveur d'applications EJB</h2>
      <ul>
         <li>Application EJB =</li>
        <li>0, 1 ou +sieurs composants EJB</li>
        <li>0, 1 ou +sieurs composants Web</li>
        <li>reliés par un schéma d'assemblage</li>
        <li>+sieurs rôles dans le développement</li>
        <li>développeur de composants Web</li>
        <li>développeur de composants EJB</li>
        <li>assembleur d'applications</li>
        <li>déployeur et gestionnaire d'applications</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>2. Serveur d'applications EJB</h2>
      <ul>
         <li>Serveur d'applications EJB</li>
        <li>4 services fournis par le serveur</li>
        <li>au conteneur EJB</li>
        <li>transaction</li>
        <li>persistance</li>
        <li>sécurité</li>
        <li>cycle de vie</li>
        <li> middleware style CORBA</li>
        <li>ces services sont intégrés dès le départ</li>
        <li>à la plate-forme</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Au sommaire aujourd’hui</h2>
      <ul>
         <li>Vers la notion de composant</li>
        <li>Architecture JEE</li>
        <li>1. 	 JavaEE Introduction</li>
        <li>Rappel sur le middleware</li>
        <li>4. 	Des spécifications sous forme d’APIs</li>
        <li>5.  	Composants Web</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3. Applications réparties</h2>
      <ul>
         <li>De nombreuses applications informatiques sont réparties de fait</li>
        <li>Services Internet, e.g. DNS, courrier électronique, news, etc.</li>
        <li>Sites Web de commerce électronique</li>
        <li>Carte bleue</li>
        <li>Téléphonie cellulaire</li>
        <li>Télévision interactive</li>
        <li>Gestion des réseaux de télécommunication</li>
        <li>Grid computing</li>
        <li>Peer to Peer</li>
        <li>Définition minimaliste : coopération d’un ensemble de logiciels s’exécutant sur plusieurs machines reliées par des réseaux de communication</li>

      </ul>
        <object data="images/image18.wmf" type="image/jpg" style="position:absolute;top:30%;left:20%;" height="50%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>3. Pourquoi des applications réparties ?</h2>
      <ul>
         <li>Besoins propres des applications</li>
        <li>Partage et/ou transfert d’information</li>
        <li>Accès à des ressources (matérielles ou logiciels) distantes</li>
        <li>Coopération / synchronisation de traitements répartis</li>
        <li>Répartition « intrinsèque » des ressources</li>
        <li>Possibilités techniques</li>
        <li>Coût et performances des machines et des communications</li>
        <li>Besoin d’interconnexion généralisée</li>
        <li>Système d’information des entreprises</li>
        <li>Interpénétration informatique - télécom - télévision</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3. L’interconnexion des systèmes d’information</h2>
      <ul>
         <li>Les entreprises ont besoin de logiciels coopérants !</li>
        <li>Les entreprises réparties ont besoin de logiciels distribués !</li>

      </ul>
        <object data="images/image19.jpeg" type="image/jpg" style="position:absolute;top:30%;left:20%;" height="50%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>3. L’interconnexion des réseau de communication</h2>
      <ul>
 
      </ul>
    </section>
    <section class='slide'>
      <h2>3. Problèmes à prendre en compte</h2>
      <ul>
         <li>Hétérogénéité</li>
        <li>Réseaux</li>
        <li>Machines</li>
        <li>Systèmes d’exploitation</li>
        <li>Langages de programmation</li>
        <li>Formats d’échange de données</li>
        <li>…</li>
        <li>Répartition</li>
        <li>Communication / coopération / coordination des logiciels répartis</li>
        <li>Sûreté de fonctionnement contre les</li>
        <li>Pannes du matériel et du logiciel</li>
        <li>Fraudes = > sécurité</li>
        <li>…</li>
        <li>Interopérabilité entre logiciels hétérogènes et répartis</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3. Au sommaire aujourd’hui</h2>
      <ul>
         <li>Vers la notion de composant</li>
        <li>Architecture JEE</li>
        <li>1. 	 JavaEE Introduction</li>
        <li>Rappel sur le middleware</li>
        <li>4. 	Des spécifications sous forme d’APIs</li>
        <li>5.  	Composants Web</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3. Intergiciel - Middleware</h2>
      <ul>
         <li>Couche logiciel réparti destinée à</li>
        <li>Masquer l’ hétérogénéité des machines et systèmes</li>
        <li>Masquer la répartition des traitements et données</li>
        <li>Fournir une interface commode aux applications (modèle de programmation + API)</li>
        <li>Nécessité de normaliser la couche intergiciel !</li>
        <li>Applications</li>
        <li>Intergiciel</li>
        <li>Site 1</li>
        <li>Site 2</li>
        <li>Interface</li>
        <li>Système de</li>
        <li>communication</li>
        <li>Système</li>
        <li>d’exploitation</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3. Les objets répartis</h2>
      <ul>
 
      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Motivations</h2>
      <ul>
         <li>Applications souvent en mode client / serveur</li>
        <li>les clients font appel à des services offerts par des serveurs distants</li>
        <li>API sockets sont de trop bas niveau et nécessitent</li>
        <li>allocation manuelle des sockets / threads</li>
        <li>sérialisation manuelle des appels de services distants</li>
        <li>emballage / déballage des données des messages</li>
        <li>sérialisation manuelle des objets complexes</li>
        <li>pas d’annuaire ni d’autres services « middleware »</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Objectif</h2>
      <ul>
         <li>Les applications sont de plus en plus conçues selon une approche orientée objet</li>
        <li>« bonnes » propriétés de l’ objet (encapsulation, modularité, réutilisation, polymorphisme, composition)</li>
        <li>Objet = unité de désignation et de distribution</li>
        <li>Permettre la communication directe et transparente entre objets répartis</li>
        <li>par ex. objetDistant.methode(parametres)</li>
        <li>transparence uniquement pour le programmeur !</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Appel de méthode à distance (1/2)</h2>
      <ul>
         <li>état</li>
        <li>Méthode_i</li>
        <li>Talon serveur</li>
        <li>Objet</li>
        <li>Référence d'objet + méthode + arguments</li>
        <li>Résultat ou exception</li>
        <li>Talon client</li>
        <li>Interface</li>
        <li>référence</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Appel de méthode à distance (2/2)</h2>
      <ul>
         <li>éléments d'une « invocation »</li>
        <li>référence d'objet (« pointeur » universel)</li>
        <li>identification d'une méthode</li>
        <li>paramètres d'appel et de retour</li>
        <li>passage par valeur : types élémentaires et types construits</li>
        <li>passage par référence</li>
        <li>possibles exceptions en retour</li>
        <li>objets « langage »</li>
        <li>représentation propre au langage : instance d'une classe</li>
        <li>exemple : Java RMI</li>
        <li>objets « système »</li>
        <li>représentation « arbitraire » définie par l'environnement d'exécution</li>
        <li>exemple : CORBA</li>

      </ul>
    </section>
    <section class='slide'>
      <h2></h2>
      <ul>
         <li>Methode_1</li>
        <li>Methode_n</li>
        <li>état</li>
        <li>objet serveur</li>
        <li>objet client</li>
        <li>appel</li>
        <li>Système de communication</li>

      </ul>
    </section>
    <section class='slide'>
      <h2></h2>
      <ul>
         <li>Methode_1</li>
        <li>Methode_n</li>
        <li>état</li>
        <li>objet serveur</li>
        <li>objet client</li>
        <li>appel</li>
        <li>Système de communication</li>
        <li>1 : Invocation d’une méthode		6 : Retour de l’invocation locale</li>
        <li>2 : Emballage des paramètres		7 : Emballage des résultats</li>
        <li>3 : Transport de l’invocation		8 : Transport des résultats</li>
        <li>4 : Déballage des paramètres		9 : Déballage des résultats</li>
        <li>5 : Invocation de l’objet		10 : Retour de l’invocation distante</li>
        <li>(1)</li>
        <li>(2)</li>
        <li>(3)</li>
        <li>(4)</li>
        <li>(5)</li>
        <li>(6)</li>
        <li>(7)</li>
        <li>(8)</li>
        <li>(9)</li>
        <li>(10)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Le rôle du talon client</h2>
      <ul>
         <li>Emballage des appels de méthodes locaux en messages à destination du talon serveur</li>
        <li>Déballage des résultats ou des exceptions contenus dans un message retourné par le talon serveur</li>
        <li>Contrôle de la bonne utilisation des signatures du talon à la compilation / l’exécution</li>
        <li>= > contrôle des messages du protocole</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Le rôle du talon serveur</h2>
      <ul>
         <li>Passerelle entre le réseau et l’objet serveur</li>
        <li>rend l’objet serveur accessible à distance</li>
        <li>Déballage des messages émis par les talons clients</li>
        <li>Appel local des méthodes de l’objet serveur</li>
        <li>Emballage des résultats ou exceptions dans un message à destination du talon client</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Le bus d’objets répartis</h2>
      <ul>
         <li>Réseau</li>
        <li>Objet</li>
        <li>Client</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. La prise en charge de la fonction de communication</h2>
      <ul>
         <li>Le développeur ne code pas la communication</li>
        <li>gestion des sockets, du protocole applicatif, des threads</li>
        <li>déballage des arguments et emballage des résultats</li>
        <li>Indépendance vis-à-vis de la couche de transport</li>
        <li>TCP/IP, ATM, . . ., mémoire partagée, . . .</li>
        <li>Amélioration de la qualité logiciel par génération</li>
        <li>Objet</li>
        <li>credit(int montant)</li>
        <li>{</li>
        <li>... code métier . . .</li>
        <li>balance_ += montant;</li>
        <li>}</li>
        <li>Talon serveur</li>
        <li>if(op == «credit»)</li>
        <li>{</li>
        <li>int m = receive();</li>
        <li>objet.credit(m) ;</li>
        <li>return;</li>
        <li>}</li>
        <li>. . .</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Le rôle du langage IDL</h2>
      <ul>
         <li>Interface Definition Language = langage de définition des interfaces des objets répartis</li>
        <li>Permet de décrire la signature des méthodes publiques et accessibles à distance</li>
        <li>nom méthode</li>
        <li>type du résultat et des paramètres</li>
        <li>liste des exceptions</li>
        <li>Caractérisation des messages du protocole applicatif entre le client et le serveur</li>
        <li>Compilation pour production automatique des talons clients et serveurs</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Le rôle du bus d’objets répartis</h2>
      <ul>
         <li>Implantation d’un protocole de transport des appels de méthode à distance</li>
        <li>Bufférisation des messages</li>
        <li>Allocation des canaux de communications</li>
        <li>sockets mais aussi «pipes», mémoire partagée, . . .</li>
        <li>des adresses physiques, e.g. des ports</li>
        <li>gestion d’un pool de sockets, . . .</li>
        <li>Gestion de pools de threads serveurs</li>
        <li>Autres services . . .</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Middleware orienté objet</h2>
      <ul>
         <li>Bus pour communication synchrone entre objets distants</li>
        <li>Mais peut aussi fournir d’autres fonctions</li>
        <li>Annuaires de recherche</li>
        <li>stockage des références d’objets distants</li>
        <li>Communication asynchrone</li>
        <li>diffusion d’événements</li>
        <li>Activation à la volée des objets</li>
        <li>objets présents en mémoire seulement si invoqués</li>
        <li>= > virtuellement des milliards d’objets ;-)</li>
        <li>Sécurité</li>
        <li>Transactions réparties</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Les diverses solutions industrielles</h2>
      <ul>
         <li>DCOM pour Distributed Component Object Model</li>
        <li>Produit de Microsoft</li>
        <li>Système d’exploitation Windows partout !</li>
        <li>Java RMI pour Java Remote Method Invocation</li>
        <li>Produit de SUN Microsystems</li>
        <li>Langage Java partout !</li>
        <li>CORBA pour Common Object Request Broker Architecture</li>
        <li>Norme du consortium Object Management Group</li>
        <li>Interopérabilité !</li>
        <li>Web Services</li>
        <li>Norme du consortium W3C</li>
        <li>Interopérabilité !</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Distributed Component Object Model</h2>
      <ul>
         <li>Principes</li>
        <li>modèle de composants « à la » Microsoft (OLE, COM)</li>
        <li>IDL = MIDL</li>
        <li>Transport = RPC DCE</li>
        <li>Avantages</li>
        <li>Large diffusion et intégration dans les systèmes d’exploitation et applications « à la » Microsoft</li>
        <li>Multi-langages</li>
        <li>Wizards pour le développement</li>
        <li>Inconvénients</li>
        <li>Un seul fournisseur</li>
        <li>Mono système d’exploitation</li>
        <li>Complexe à maîtriser</li>
        <li>RPC DCE inadapté pour l’Internet</li>
        <li>voir SOAP (Simple Object Access Protocol) : DTD XML</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Java RMI</h2>
      <ul>
         <li>Principes</li>
        <li>Tout Java</li>
        <li>IDL = interfaces Java ( extends java.rmi.Remote )</li>
        <li>Transport = JRMP ou IIOP</li>
        <li>Avantages</li>
        <li>Intégré aux environnements JDK</li>
        <li>Simple à mettre en œuvre</li>
        <li>Inconvénients</li>
        <li>Un seul concepteur</li>
        <li>Mono langage</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. CORBA</h2>
      <ul>
         <li>Principes</li>
        <li>Modèle d’objets hétérogènes et interopérables</li>
        <li>IDL = OMG IDL</li>
        <li>Transport = GIOP - IIOP (Internet Inter Orb Protocol)</li>
        <li>Avantages</li>
        <li>Norme consensuelle OMG / ISO</li>
        <li>fournisseurs / utilisateurs / domaines</li>
        <li>Ouvert et évolutif</li>
        <li>Multiples fournisseurs d’implantations</li>
        <li>Multi langages / OS / transports</li>
        <li>Middleware avec de nombreux services</li>
        <li>Inconvénients</li>
        <li>« Réputé » pour être complexe à mettre en œuvre ;-)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.1. Web Services</h2>
      <ul>
         <li>Un cours dédié</li>

      </ul>
    </section>
    <section class='slide'>
      <h2></h2>
      <ul>
         <li>3.2. Un exemple avec Java RMI</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Des objets aux objets répartis</h2>
      <ul>
         <li>Objet</li>
        <li>1. Une interface (type abstrait)</li>
        <li>2. Une classe (type concret)</li>
        <li>3. Une instance avec une référence locale (valeur d’un compteur, adresse mémoire)</li>
        <li>Objet distant</li>
        <li>1. Une interface pour des invocations distantes</li>
        <li>- décrit dans le langage d’implantation : Java (RMI)</li>
        <li>- autre cas : décrit dans un langage différent : IDL (RPCsun, CORBA)</li>
        <li>2. Une interface locale limitée aux accès internes au processus (optionnel)</li>
        <li>3. Une classe</li>
        <li>4. Une instance avec une référence globale (ident hôte, ident processus, ident objet)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Objets langages ou objets systèmes</h2>
      <ul>
         <li>Objet « langage »</li>
        <li>- Représentation propre au langage : instance d’une classe</li>
        <li>- Exemple : Java RMI</li>
        <li>Objet « système »</li>
        <li>- Représentation « arbitraire » définie par l’environnement d’exécution</li>
        <li>- Exemple CORBA</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. RMI : Remote Method Invocation</h2>
      <ul>
         <li>Objet</li>
        <li>client</li>
        <li>Talon client</li>
        <li>( stub ou proxy )</li>
        <li>Objet</li>
        <li>serveur</li>
        <li>Squelette serveur</li>
        <li>( skeleton )</li>
        <li>Remote Reference layer</li>
        <li>Hôte 1</li>
        <li>processus 1</li>
        <li>Hôte 2</li>
        <li>processus 2</li>
        <li>Client</li>
        <li>Serveur</li>
        <li>JVM</li>
        <li>JVM</li>
        <li>RPC objet intégré à Java</li>
        <li>Interaction d’objets situés dans des espaces d’adressage différents sur</li>
        <li>des machines distinctes</li>
        <li>Transport</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. RMI : Remote Method Invocation</h2>
      <ul>
         <li>Côté client : talon</li>
        <li>- offre la même interface que l’objet serveur</li>
        <li>- lié à un seul serveur</li>
        <li>- mise sous forme de flot d ’octets des requêtes (ident méthode, arguments)</li>
        <li>- autres caractéristiques :</li>
        <li>- partage de charge,	- statistiques,</li>
        <li>-...</li>
        <li>Côté serveur : squelette</li>
        <li>- Représente l’objet serveur</li>
        <li>- lié à un seul serveur</li>
        <li>- possibilité d’avoir plusieurs squelettes pour un serveur</li>
        <li>- récupération du flot d’octets et appel de la méthode correspondante sur l’objet serveur</li>
        <li>- autres caractéristiques :</li>
        <li>- persistance,</li>
        <li>- ...</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. RMI : Remote Method Invocation</h2>
      <ul>
         <li>Serveur</li>
        <li>- conception de l’interface du serveur et implantation de la classe du serveur</li>
        <li>- le squelette serveur peut être lié à l’objet serveur</li>
        <li>- en implantant une interface spécifique</li>
        <li>- en héritant d’une classe spécifique (approche par héritage)</li>
        <li>- de façon implicite dans le code de démarrage du serveur, par création explicite et liaison d’un squelette à l’objet serveur</li>
        <li>- instancier un serveur qui crée des objets serveurs</li>
        <li>- à la demande (fabrique)</li>
        <li>- lier les objets serveurs (service de noms)</li>
        <li>Client</li>
        <li>- liaison de l’objet client avec le talon de l’objet distant</li>
        <li>- obtenir la référence de l’objet serveur</li>
        <li>- invoquer la méthode</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Architecture de Java RMI</h2>
      <ul>
         <li>Permettre l’interaction des objets distribués Java</li>
        <li>à travers des invocations de méthodes (distantes)</li>
        <li>les invocations sont synchrones (même s’il n’y a pas de réponse)</li>
        <li>RPC intégré au langage</li>
        <li>complètement intégré au langage Java</li>
        <li>les interfaces distantes sont décrites à travers des interfaces Java</li>
        <li>Compilation séparée</li>
        <li>génération de talons et squelettes en accord avec les interfaces</li>
        <li>Depuis Java 1.1</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Architecture de Java RMI</h2>
      <ul>
         <li>Client</li>
        <li>Serveur</li>
        <li>Skeleton</li>
        <li>Stub</li>
        <li>Naming</li>
        <li>Naming</li>
        <li>rmiregistry</li>
        <li>1</li>
        <li>2</li>
        <li>2</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>3</li>
        <li>6</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>8</li>
        <li>8</li>
        <li>JVM Client</li>
        <li>JVM Serveur</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Mode opératoire côté serveur</h2>
      <ul>
         <li>1 - l’objet serveur s’enregistre auprès du naming de sa</li>
        <li>JVM (méthode rebind )</li>
        <li>2 - l’objet skeleton  est créé, celui-ci crée le port de communication et maintient une référence vers l’objet serveur</li>
        <li>3 - Le Naming enregistre l’objet serveur et le port de communication utilisé auprès du serveur de noms (rmiregistry)</li>
        <li>L’objet serveur est alors prêt à répondre aux requêtes de clients</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Mode opératoire côté client</h2>
      <ul>
         <li>4 - L ’objet client fait appel au Naming pour localiser l’objet serveur (méthode lookup )</li>
        <li>5 - Le Naming récupère les références vers l’objet serveur</li>
        <li>6 - l’objet stub  est créé, celui-ci crée le port de communication</li>
        <li>7 - Le client maintient une référence vers le stub</li>
        <li>8 - Le client effectue l’appel au serveur par appel à l’objet Stub</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Conception d’une application Java RMI</h2>
      <ul>
         <li>La démarche</li>
        <li>1. Ecrire l’interface de service</li>
        <li>2. Ecrire la classe du service</li>
        <li>3. Ecrire le serveur</li>
        <li>4. Ecrire le client</li>
        <li>5. Compiler l ’application avec javac</li>
        <li>6. Générer les talons et les squelettes avec rmic</li>
        <li>7. Lancement du serveur de noms ( rmiregistry )</li>
        <li>8. Lancement du serveur</li>
        <li>9. Lancement du client</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.2. Une vision d’ensemble de l’application</h2>
      <ul>
         <li>Serveur</li>
        <li>Client</li>
        <li>rmiregistry</li>
        <li>HelloImpl</li>
        <li>_Stub</li>
        <li>HelloImpl</li>
        <li>helloDistant</li>
        <li>HelloImpl</li>
        <li>_Skel</li>
        <li>HelloImpl</li>
        <li>_Stub</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.3. Conclusion RMI</h2>
      <ul>
         <li>Très bon exemple de RPC</li>
        <li>facile à utiliser</li>
        <li>intégration du langage Java et Internet</li>
        <li>utilisation de l’apport de Java</li>
        <li>plates-formes hétérogènes - > machines virtuelles</li>
        <li>persistance - > sérialisation</li>
        <li>passage par valeur - > sérialisation</li>
        <li>désignation - > URL</li>
        <li>absence de talon - > chargement dynamique</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.3. Conclusion RMI</h2>
      <ul>
         <li>Avantages de Java RMI</li>
        <li>Premier niveau de programmation objets distribués (invocation statique à distance d'objets)</li>
        <li>Richesse des environnements JAVA</li>
        <li>Ramasse-miettes distribué</li>
        <li>Plusieurs sémantiques d'invocations (point-à-point, dupliqué,...)</li>
        <li>Garantie de la sécurité par le système de chargement de classe et le gestionnaire de sécurité</li>
        <li>Inconvénients de Java RMI</li>
        <li>Langage homogène / CORBA</li>
        <li>Modèle d'exécution de la machine virtuelle JAVA avec le système de threads pas suffisamment défini (portage difficile d'applications multithreadées avec appels distants)</li>
        <li>Invocation statique</li>
        <li>Pas de services distribués associés : extension possible vers JNDI : Java Naming and Directory Interface</li>

      </ul>
    </section>
    <section class='slide'>
      <h2></h2>
      <ul>
         <li>3.4. Comparaison RMI Corba</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.4. Standards pour l’interopérabilité</h2>
      <ul>
         <li>Standards sont des consensus pour gérer l’interopérabilité</li>
        <li>Définis en commun</li>
        <li>Appliqués par tous</li>
        <li>De nombreux organismes de standardisation</li>
        <li>International Standardization Organization (ISO)</li>
        <li>International Telecommunication Union (ITU)</li>
        <li>TeleManagement Forum</li>
        <li>Object Management Group (OMG)</li>
        <li>World Wide Web Consortium (W3C)</li>
        <li>. . .</li>

      </ul>
        <object data="images/image28.wmf" type="image/jpg" style="position:absolute;top:30%;left:20%;" height="50%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>3.4. Intergiciel CORBA</h2>
      <ul>
         <li>Compilateur</li>
        <li>OMG IDL</li>
        <li>Interface</li>
        <li>OMG IDL</li>
        <li>Objet</li>
        <li>Client</li>
        <li>Souche</li>
        <li>Squelette</li>
        <li>POA</li>
        <li>ORB</li>
        <li>ORB</li>
        <li>IIOP sur réseau Internet</li>
        <li>Appels de méthodes à distance</li>
        <li>Transparence vis-à-vis de la distribution et de l’hétérogénéité</li>
        <li>Optimisation si co-localisation</li>
        <li>i.e. pas IIOP ni réseau</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.4. Object Management Architecture</h2>
      <ul>
         <li>Bus d’objets répartis CORBA</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.4. Un environnement pour des applications réparties</h2>
      <ul>
         <li>Services applicatifs</li>
        <li>fichiers répartis, moniteur transactionnel, accès BD, ...</li>
        <li>Services systèmes</li>
        <li>communication, RPC, désignation, sécurité, ...</li>
        <li>Système d’exploitation</li>
        <li>Machines et Réseaux</li>
        <li>outils</li>
        <li>de</li>
        <li>développement</li>
        <li>outils</li>
        <li>d’</li>
        <li>administration</li>
        <li>intergiciel</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.4. Comparaison de Java RMI avec CORBA</h2>
      <ul>
         <li>RMI est propriétaire SUN / CORBA est une norme internationale</li>
        <li>RMI moins ambitieux que CORBA</li>
        <li>RMI n'offre pas interopérabilité avec des objets d'autres langages</li>
        <li>RMI est beaucoup plus lent que les implantations de CORBA</li>
        <li>RMI est une implantation standard et gratuite (incluse dans JDK)</li>
        <li>RMI est object-oriented / CORBA est object-based</li>
        <li>RMI est plus simple à mettre en œuvre que CORBA</li>
        <li>Pas besoins d'IDL : seulement l'interface de l'OD et son URL</li>
        <li>Les OD se manipulent comme les OL (grâce au DGC)</li>
        <li>RMI supporte le passage d'objets locaux par copie</li>
        <li>RMI permet une gestion de la sécurité ( RMISecurityManager , ACL, ...)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.4. Conclusion sur les RPCs</h2>
      <ul>
         <li>RPC intégrés au langage (First Class RPC)</li>
        <li>Avantages 		- facile à utiliser</li>
        <li>Inconvénients 	- ouverture limitée,</li>
        <li>- restriction des langages utilisés par le client</li>
        <li>RPC hétérogènes (Second Class RPC)</li>
        <li>Avantages 		- plus difficile à utiliser</li>
        <li>Inconvénients  	- indépendance par rapport aux langages de 				programmation,</li>
        <li>- choix du langage</li>
        <li>- interopérabilité</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>3.4. Quelques aspects (en vrac) à prendre en compte</h2>
      <ul>
         <li>Organisation des applications</li>
        <li>Structuration des traitements et des données</li>
        <li>Modèle de coopération / coordination / communication</li>
        <li>Méthodes et outils favorisant</li>
        <li>la construction, le déploiement, l’exécution et l’administration des applications</li>
        <li>Sûreté de fonctionnement</li>
        <li>contre les fraudes et les pannes</li>
        <li>Autres</li>
        <li>Intégration, disponibilité et capacité de croissance</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4. Des spécifications sous forme d’APIs</h2>
      <ul>
 
      </ul>
    </section>
    <section class='slide'>
      <h2></h2>
      <ul>
         <li>4.1. RMI</li>
        <li>Remote Method Invocation</li>
        <li>Java seulement, mais passerelles</li>
        <li>« RPC objet » (appels sur objets distants)</li>
        <li>Service de nommage (RMI registry)</li>
        <li>Sécurité paramétrable (SecurityManager)</li>
        <li>Garbage Collection distribuée</li>
        <li>Téléchargement de code</li>
        <li>Fonctions avancées</li>
        <li>Activation d ’objets persistants, Réplication</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. JNDI le besoin d’un service de nommage</h2>
      <ul>
         <li>Serveur</li>
        <li>Client</li>
        <li>rmiregistry</li>
        <li>HelloImpl</li>
        <li>_Stub</li>
        <li>HelloImpl</li>
        <li>helloDistant</li>
        <li>HelloImpl</li>
        <li>_Skel</li>
        <li>HelloImpl</li>
        <li>_Stub</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. JNDI - Concepts de base</h2>
      <ul>
        <li>La notion de nommage:</li>
        <li>Un service de nommage permet d'associer un nom unique à un objet et faciliter ainsi l'obtention de cet objet.</li>
        <li>L’identification doit être aisée et précise.</li>
        <li>La localisation et l’accès à une ressource sont donc facilitées par le nommage.</li>
        <li>Beaucoup de services de nommage sont étendus avec un service d’annuaire.</li>
        <li>Exemple: Internet et son système de nommage, le DNS ( Domain Name System )</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. JNDI - Concepts de base</h2>
      <ul>
         <li>Concept de gestion des ressources par annuaire:</li>
        <li>L’annuaire est un service de nommage.</li>
        <li>Il possède en plus une représentation hiérarchique des objets contenus.</li>
        <li>Il possède un mécanisme de recherche permettant de rendre transparent l’accès aux ressources pour l’utilisateur.</li>
        <li>Exemple: Le service de gestion d’annuaire LDAP ( Lightweight Directory Access Protocol ).</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. JNDI - Concepts de base</h2>
      <ul>
         <li>La concept de contexte:</li>
        <li>Un contexte est un ensemble de liens nom-objet.</li>
        <li>Chaque contexte a une convention de nommage associé.</li>
        <li>Il fournit un moyen de consultation (résolution) qui reçoit l’objet et peut fournir d’autres opérations telles que:</li>
        <li>La liaison de nom (Binding)</li>
        <li>La suppression de cette liaision (unbinding)</li>
        <li>Un nom peut-être lié à un objet de contexte, appelé alors sous-contexte.</li>
        <li>JNDI manipule des contextes avec l’interface context .</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. JNDI - Présentation</h2>
      <ul>
        <li>JNDI (Java Naming and Directory Interface)</li>
        <li>JNDI est une spécification qui fournit une interface unique pour utiliser différents services de nommages ou d'annuaires.</li>
        <li>Ces services peuvent être:</li>
        <li>LDAP (Lightweigth Directory Access Protocol)</li>
        <li>DNS (Domain Naming Service)</li>
        <li>NIS (Network Information Service) de SUN</li>
        <li>Service de nommage CORBA</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. Quand utiliser JNDI ?</h2>
      <ul>
        <li>JNDI est un composant important de J2EE que plusieurs technologies comme les EJB, JDBC ou JMS utilisent.</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. Pourquoi JNDI ?</h2>
      <ul>
         <li>A mesure que l’utilisation du langage Java pour développer des applications distribuées dans un environnement réseau augmente, la faculté d’accéder à des services d’annuaire devient essentielle.</li>
        <li>En effet, l’utilisation d’un service d’annuaire permet de simplifier les applications et leur administration en centralisant le stockage d’information partagée.</li>
        <li>C’est pourquoi JNDI est un outil de plus en plus utilisé par les développeurs.</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.2. JNDI</h2>
      <ul>
         <li>API accès aux annuaires</li>
        <li>javax.naming</li>
        <li>« Service Provider » par annuaire cible (LDAP, NIS, RMI registry…)</li>
        <li>Utilisation avec les EJB</li>
        <li>Accès à l ’interface « home » pour initialiser</li>
        <li>Accès à diverses ressources (UserTransaction, Queues JMS, DataSources…)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.3. JMS</h2>
      <ul>
         <li>Java Messaging Service</li>
        <li>JMS Provider : inclus dans J2EE</li>
        <li>Transport synchrone ou asynchrone, Garantie de livraison</li>
        <li>« Messaging domains » point à point ou « publish/subscribe »</li>
        <li>Lien avec EJB : « message-driven bean »</li>
        <li>Pour échanges asynchrones</li>

      </ul>
    </section>
    <section class='slide'>
      <h2></h2>
      <ul>
         <li>4.4. API JavaEE de transactions : JTA</li>
        <li>Java Transaction API</li>
        <li>Package javax.transaction</li>
        <li>TransactionManager : begin(), commit(), rollback() …</li>
        <li>Transaction : commit(), rollback(), enlistResource(XAResource), registerSynchronisation(Synchronization) ...</li>
        <li>Synchronization : beforeCompletion(), afterCompletion(commit | rollback)</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.5. JMX</h2>
      <ul>
         <li>Java Management eXtensions</li>
        <li>API unique pour applications de management</li>
        <li>Mbeans avec accesseurs get/set</li>
        <li>Typage faible, attributs nommés</li>
        <li>Serveur JMX</li>
        <li>Enregistrement des Mbeans</li>
        <li>Les applis d ’administration dialoguent avec le serveur JMX</li>
        <li>Instrumenter un composant</li>
        <li>Fournir un ou des Mbeans</li>
        <li>Les enregistrer auprès du serveur JMX</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>4.5. JMX : Exemple d ’un serveur JavaEE</h2>
      <ul>
         <li>Java EE Server</li>

      </ul>
        <object data="images/image14.jpeg" type="image/jpg" style="position:absolute;top:30%;left:20%;" height="50%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>4.6. Les APIs de JavaEE</h2>
      <ul>
         <li>(standards connexes)</li>
        <li>■ Java Servlets</li>
        <li>■ JavaServer Pages (JSP)</li>
        <li>■ Enterprise JavaBeans</li>
        <li>■ Java Message Service (JMS)</li>
        <li>■ JDBC - JPA</li>
        <li>■ Transactions</li>
        <li>JTA</li>
        <li>JTS</li>
        <li>■ J2EE Connector Architecture (JCA)</li>
        <li>■ Corba (Java IDL)</li>
        <li>■ JavaMail</li>
        <li>■ XML/SOAP</li>
        <li>Java API for XML Processing (JAXP)</li>
        <li>Java API for XML Registries (JAXR)</li>
        <li>Java API for XML-Based Remote Procedure Call (JAX-RPC)</li>
        <li>SOAP with Attachments API for Java (SAAJ)</li>
        <li>■ J2EE Deployment Specification (JSR-88)</li>
        <li>■ J2EE Management Specification (JSR-77)</li>
        <li>■ JMX</li>

      </ul>
        <object data="images/image31.png" type="image/jpg" style="position:absolute;top:30%;left:20%;" height="50%"
                            width="60%"></object>

    </section>
    <section class='slide'>
      <h2>5.  Composants Web</h2>
      <ul>
 
      </ul>
    </section>
    <section class='slide'>
      <h2>5.  Composants Web</h2>
      <ul>
         <li>Web Bean</li>
        <li>Un ensemble de</li>
        <li>JSP et/ou</li>
        <li>servlet et/ou</li>
        <li>pages HTML</li>
        <li>packagés dans un fichier archive .war (idem .jar)</li>
        <li>Composants "à cheval" entre les logiques de présentation et de traitement</li>
        <li>implantent une logique de présentation simple pour des clients Web</li>
        <li>servent de passerelle d'accès pour des composants EJB</li>
        <li>peuvent implanter une logique de "petits" traitements</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>5.  Composants Web</h2>
      <ul>
         <li>Exemple Web Bean JSP</li>
        <li>Web bean Calculatrice</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>5.  Composants Web</h2>
      <ul>
         <li>import javax.servlet.*;</li>
        <li>import javax.servlet.http.*;</li>
        <li>import java.io.*;</li>
        <li>public class HelloServlet extends HttpServlet {</li>
        <li>public void</li>
        <li>service ( ServletRequest request , ServletResponse response )</li>
        <li>throws ServletException, IOException {</li>
        <li>response.setContentType( "text/html" );</li>
        <li>PrintWriter out = response.getWriter();</li>
        <li>out.println( " < html > < body > ... < /body > < /html > " );</li>
        <li>} }</li>
        <li>Exemple Web Bean servlet</li>
        <li>Démo …</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Conclusion : Limites de la programmation usuelle</h2>
      <ul>
         <li>Tout est la charge du programmeur</li>
        <li>Construction des différents modules logiciels</li>
        <li>Définition des instances</li>
        <li>Interconnexions des instances</li>
        <li>Structure de l’application peu visible</li>
        <li>Ensemble des fichiers de codes nécessaire</li>
        <li>Evolution / modification difficile</li>
        <li>Changement du mode de communication</li>
        <li>Evolution, ajout, suppression de fonctionnalités</li>
        <li>Modification du placement</li>
        <li>Développement, génération des exécutables, déploiement</li>
        <li>pas ou peu d’outils pour les applications réparties</li>
        <li>« programming in the small »</li>

      </ul>
    </section>
    <section class='slide'>
      <h2>Merci pour votre attention</h2>
      <ul>
 
      </ul>
    </section>



<div class="progress">
    <div></div>
</div>
<script src="scripts/kslideScript.js"></script>


</body>
</html>